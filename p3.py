""" Python高级数据类型 """

"""
# 序列：是一组按照顺序排列的值【数据集合】
--在python中存在三种内置的序列类型：字符串、列表、元组。
--优点：可以支持索引和切片的操作
--特征：第一个正索引为0，指向的是左端，第一个索引为负数的时候，指向的是右端
"""

"""
# 切片：是指截取字符串中的其中一段内容。可以根据下标来获取序列对象的任意[部分]数据。【高级特性】
--使用语法：[起始下标：结束下标：步长] / [start:end:step]
--左包含右不包含：切片截取的内容不包含结束下标对应的数据。
--step步长：指的是隔几个下标获取一个字符。默认为1。

--特点：下标会越界，切片不会。
  （即：若我们单纯用下标取数据，若越界会报异常；但切片不会，若切片数据超过长度，顶多没有数据返回，不会报越界错误）
"""

"""
# 列表list: 是一种有序的数据集合。
--特点：
  1：支持增删改查
  2：列表中的数据是可以变化的【数据项可以变化，内存地址不会改变】
  3：用[]来表示列表类型，数据项之间用逗号来分割。注意：数据项可以是任何类型的数据
  4：支持索引和切片来进行操作
--常用方法：
 .append  在列表后面追加元素
 .count   统计元素出现的次数
 .extend  扩展，相当于批量添加
 .index   获取指定元素索引号
 .insert  在指定位置插入
 .pop     删除最后一个元素
 .remove  移除左边找到的第一个元素
 .reverse 反转列表
 .sort    列表排序  ( reverse=True 倒序
"""

"""
# 元组：是一种不可变的序列，在创建之后不能做任何的修改
--特点：
  1：不可变
  2：用（）创建元组类型，数据项用逗号来分割
  3：可以是任何的类型
  4：当元组中只有一个元素时，要加上逗号，不然后解释器会当做其他类型来处理
  5：同样可是支持切片操作
  6：元组也是通过下标进行访问
--元组的内置方法count，统计元素在元组中出现的次数
--元组的内置方法index 查找指定元素在元组中的下标索引
"""

"""
range(start, stop, step)
--start: 计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）;
--stop: 计数到 stop 结束，但不包括 stop。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5
--step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)
--eg:
>>>range(10)        # 从 0 开始到 10
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> range(1, 11)     # 从 1 开始到 11
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> range(0, 30, 5)  # 步长为 5
[0, 5, 10, 15, 20, 25]
>>> range(0, 10, 3)  # 步长为 3
[0, 3, 6, 9]
>>> range(0, -10, -1) # 负数
[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
>>> range(0)
[]
>>> range(1, 0)
[]
"""

"""
# 字典： 字典是由键值对组成的集合，{'key':'value'}，利用大括号包裹着。可以存储任意对像。
        通常使用key键来访问数据，效率非常高。和list一样，支持对数据的添加、修改、删除。
--特点：
  1：不是序列类型，没有下标的概念，不能用索引来访问，是一个无序的键值集合，是python内置的高级数据类型
  2：用 {} 来表示字典对象，每个键值对用逗号分隔
  3：键 必须是不可变的类型【eg: 数字、元组、字符串】 值可以是任意的类型，值可以重复可以变
  4：每个键必定是唯一的；如果存在重复的键，后者会覆盖前者      
"""

"""
# 公用方法：
--合并操作 +
  两个对象相加操作，会合并两个对象。 适用于：字符串，列表，元组
--复制 * 
  对象自身按指定次数进行 + 操作。 适用于：字符串，列表，元组
--in 判断元素是否存在
  判断指定元素是否存在于对象中。 适用于：字符串，列表，元组，字典
"""

"""
字符串、列表、元组 -》 都是有序列的【特点：可以支持索引操作/使用数字下标访问数据】，为切片的使用打下基础，切片的使用时建立在索引的基础上
列表是可修改的序列；元组是不可变的序列
字典不是序列，不可用索引/序列操作
"""






'''
# 1.字符串及常用方法 ********************************************************
'''

# ----------------------------------------------用下标取数据
Test = 'python'
print(type(Test))
print("获取第一个字符%s" % Test[0])  # 第一个
print("获取第一个字符%s" % Test[1])  # 第二个
print("获取第一个字符%s" % Test[5])  # 最后一个
print("获取第一个字符%s" % Test[6])  # 越界，报错

# ----------------------------------------------for用下标取整个字符串
for item in Test:
    print(item, end=' ')

# ----------------------------------------------.capitalize() 首字母变大写
name = 'peter'
print('单词首字母转换大写%s' % name.capitalize())

# ----------------------------------------------.strip() 去除两边空格
a = '     hello      '
b = a.strip()  # .strip 去除两边空格
print(a)
print(b)
c = a.lstrip()  # .lstrip 删除左边空格
d = a.rstrip()  # .rstrip 删除右边空格
print(c)
print(d)

# ----------------------------------------------=复制字符串
a = 'python'
b = a  # 在此只是把a对象的内存地址赋给了b
print(id(a))
print(id(b))  # 这里a和b的内存地址是一样的
# id()函数 可以查看一个对象的内存地址

# ----------------------------------------------.find() 查找目标对象在序列对象中第一次出现的下标值
a = 'I love Python'
print(a.find('P'))  # 返回目标对象字符在字符串中的第一个下标值（0开始
print(a.find('o'))  # 只返回第一次出现的下标
print(a.find('M'))  # 如果没有找到返回-1

# ----------------------------------------------.index() 检测字符串中是否包含子字符串 返回的是下标值
a = 'I love Python'
print(a.index('P'))
print(a.index('o'))
print(a.index('M'))  # index如果没有找到对象的数据会报异常

# ----------------------------------------------.startswith() /.endswith() 判断开头/结尾
a = 'I love Python'
print(a.startswith('I'))  # 判断是否以...开头，布尔值
print(a.startswith('Io'))  # 判断时作为一个整体
print(a.endswith('n'))  # 判断是否以...结尾，布尔值

# ----------------------------------------------.lower()/.upper() 转换成小写/大写
a = 'I love Python'
print(a.lower())  # 都转换成大写
print(a.upper())  # 都转换成大写
print(a.swapcase())  # 大写的转成小写，小写的转成大写

# ----------------------------------------------总结
# .capitalize()  首字母变大写
# .endswith/startswith()   是否以x结束/开始
# .find()   检测x是否在字符串中
# .isalnum()  判断是否是字母和数字
# .isalpha()  判断是否是字母
# .isdigit()  判断是否是数字
# .islower()  判断是否是小写
# .join()   循环取出所有值用xx去连接
# .swapcase()   大写变小写，小写变大写
# .lstrip/rstrip/strip()   移除左/右/两侧空白
# .split()   切割字符串
# .title()    把每个单词的首字母变成大写
# .replace(old, new, count=None)   old被换字符串，new替换字符串，count换多少个。无count表示全部替换。
# .count()   统计出现的次数


'''
# 1.切片 ********************************************************
# slice [start:end:step] 左闭右开   start<=value<end 下标范围
'''
# ----------------------------------------------切片各种操作
a = 'abcdefgh'
print(a[2])  # 取下标为2的数据，即直观来看第3个
print(a[2:5])  # 取下标为2-4的，即直观来看第3-5个数据
print(a[2:])  # 取下标为2-最后一个的，即直观来看第3-最后的数据
print(a[:3])  # 取前三个
print(a[:])  # 输出所有
print(a[::-1])  # 倒叙输出 负号表示方向 从右边往左去遍历
print(a[5:1:-1])  # 从下表5到下标2的数据，即直观来看第6-3个数据

"""
 列表 ********************************************************
"""

# ----------------------------------------------初始化/定义列表
l = []  # 空列表
print(type(l))

# ----------------------------------------------长度为列表中元素个数
l = [1, 2, 3, '你好呀']  # 空列表
print(type(l))
print(len(l))

# ----------------------------------------------原始list
listA = ['abcd', 785, 12.23, 'qiuzhi', True]

# ----------------------------------------------各种切片
print(listA)  # 输出完整的列表
print(listA[0])  # 输出第一个元素
print(listA[1:3])  # 输出第2,3个元素
print(listA[2:])  # 从第3个元素开始到最后所以的元素
print(listA[::-1])  # 倒叙输出，从右向左输出

print(listA * 3)  # 输出多次数据/复制

# ----------------------------------------------.append 增加元素
print("-----------增加----------")
listA.append(['fff', 'ddd'])  # 追加一个list，即可以嵌套成【 ， ， 【 ，】】
print(listA)

listA.append(8888)
print(listA)

# ----------------------------------------------.insert 插入元素
print("-----------插入----------")
listA.insert(1, '这是插入到下标为1，眼见为第二个的位置的数据')  # 需要 一个位置下标+插入数据
print(listA)

# ----------------------------------------------.extend 拓展list
print("-----------拓展----------")
# 将range生成的数据强制转换成list对象
a = range(10)  # range() 返回的是一个可迭代对象（类型是对象）
listA.extend(a)  # 拓展  = 批量添加
print(listA)

listA.extend([1, 2, 3, 4, 5])  # 拓展，这时添加的直接作为原list的拓展加入，而不是整个list作为一个元素嵌套进原list
print(listA)

# listA.extend(1) #这是不行的，因为拓展相当于批量操作，要先形成一个“批”，即list
# print(listA)

# ----------------------------------------------修改
print("-----------修改----------")
listA[0] = '111'  # 用下标找到元素修改即可
print(listA)

# ----------------------------------------------del 单个删除
print("-----------删除----------")
listB = list(range(10, 50))
print(listB)
del listB[0]  # 删除列表的第一个元素
print(listB)

# ----------------------------------------------del 利用切片批量删除
listC = list(range(10, 50))
del listC[1:3]  # 利用slice批量删除下标为1.2的元素,即直观来看第2.3个元素
print(listC)

# ----------------------------------------------.remove
listB = list(range(10, 50))
listB.remove(11)  # 移除指定项，即一处括号里的元素 【参数是具体的数据值
print(listB)

# ----------------------------------------------.pop
listB = list(range(10, 50))
listB.pop(0)  # 移除指定下标的项，即移除下标为0的元素，即第一个 【参数是索引值
print(listB)

listB = list(range(10, 50))
listB.pop()  # 默认移除最后一个
print(listB)

# ----------------------------------------------.index 返回某数据的索引下标
listB = list(range(10, 21))
print(listB.index(10))  # 返回的是索引下标，即10在list种的下标

listB = list(range(10, 21))
print(listB.index(10, 11, 20))  # index( 要查找的数据, 开始查找的下标, 结束查找的下标)
# 这里会提示 10 is not in list ,即指10不在下标为11-20的范围内

listB = list(range(10, 21))
print(listB.index(10, 0, 5))
# 这里会返回10的下标为0，即在下标为0-5的范围内查找10能找到其下标为0


"""
 元组 ********************************************************
"""

# ----------------------------------------------元组的创建 不能进行修改 只能查询获取（by切片
tupleA = ()
print(type(tupleA))
tupleA = ('abcd', 89, 9.12, 'p', [11, 22, 33])
print(tupleA)

# ----------------------------------------------遍历查找
for item in tupleA:
    print(item, end=' ')

# ----------------------------------------------通过下标查询
print(tupleA[2])  # 取下标为2的，即直观看第三个

# ----------------------------------------------通过切片查询
print(tupleA[2:4])  # 通过切片取

# ----------------------------------------------从右往左 依次取 /反转字符串
print(tupleA[::-1])

# ----------------------------------------------利用负的下标各种取数据
print(tupleA[::-2])  # -2为step步长，即反转字符串，每隔两个取一次
print(tupleA[::-3])  # -3为step步长，即反转字符串，每隔三个取一次

print(tupleA[-2:-1:])  # 默认步长为1。 取下标为-2的数据，即倒数第二个数据
print(tupleA[-4:-2:])  # 默认步长为1。 取下标为-4到-2的数据

print(tupleA[-2:-4:-1])  # 需要倒着取时步长要设置为负数
print(tupleA[-2:-4:])  # 此时是取不出数据的，因为从倒数第二个到倒数第四个，方向明明是倒着的，但默认步长为1意味着要正向取，所以取不到数据

# ----------------------------------------------
tupleA = ()
print(id(tupleA))
tupleA = ('abcd', 89, 9.12, 'p', [11, 22, 33])
print(id(tupleA))  # 两次地址是不一样的

# ----------------------------------------------对元组中的列表类型元素可以修改
# tupleA[0] = 'pppp'  # 错误的，因为元组不能修改
tupleA = ('abcd', 89, 9.12, 'p', [11, 22, 33])
tupleA[4][0] = 88888  # 可以对元组中的列表类型的数据进行修改

# ----------------------------------------------
# 当元组中只有一个数据项的时候，必须要在第一个数据项后面加上，逗号
tuple1 = (1)
print(type(tuple1))  # int
tuple2 = ('1')
print(type(tuple2))  # string
tuple3 = (1,)
print(type(tuple3))  # tuple
tuple4 = ('1',)
print(type(tuple4))  # tuple

# ----------------------------------------------
tupleC = tuple(range(10))  # 强转换为tuple类型
print(tupleC)

# ----------------------------------------------.count()统计元素出现的次数
tupleC = (1, 2, 3, 4, 3, 4, 4, 1)
print(tupleC.count(4))  # 可以统计元素出现的次数

# ----------------------------------------------.index()
tupleC = (5, 7, 3, 4, 8, 9, 4, 1)
print(tupleC.index(8))


"""
 字典 ********************************************************
"""

# ----------------------------------------------创建字典
dictA = {}
print(type(dictA))

# ----------------------------------------------填充/添加字典数据
dictA['name'] = '深深'  # dictA[key] = value
dictA['age'] = 28
dictA['pos'] = '歌手'
print(dictA)

# ----------------------------------------------声明时添加
dictB = {'pos': '艺术', 'school': '乌克兰国立音乐学院'}
dictB['age'] = 28
print(dictB)  # 输出完整的字典
print(len(dictB))  # 数据项长度

# ----------------------------------------------通过键擦回到对应的值
print(dictA['name'])

# ----------------------------------------------修改
dictA['name'] = '毛毛'   # 修改键对应的值
print(dictA)

dictA.update({'age': 25})  # 用update方法修改
print(dictA)

# ----------------------------------------------遍历获取所有的键(是个集合) /值
print(dictA.keys())  # 获取所有的键
print(dictA.values())  # 获取所有的值
print(dictA.items())  # 获取所有的键值对

for item in dictA.items():
    print(item)

for key, value in dictA.items():  # 这个items元组本身时两项数据，定义两个变量接收
    print('key', '==', value)

for key, value in dictA.items():  # 这个items元组本身时两项数据，定义两个变量接收
    print('%s==%s' % (key, value))

# ----------------------------------------------通过指定键删除
del dictA['name']  # by切片
print(dictA)

dictA.pop('age')  # by函数
print(dictA)

# ----------------------------------------------用内置函数对字典进行排序-按ASCILL码
dictC = {'name': '深深', 'pos': '歌手', 'school': '乌克兰国立音乐学院', 'age': 28}
# 按照key排序
print(sorted(dictC.items(), key=lambda d:d[0]))  # d用来指定排序的参考，d[0]表示按照key的内容来排序 ； lambda是个匿名函数
# 按照value排序
# print(sorted(dictC.items(), key=lambda d:d[1]))  # d用来指定排序的参考，d[1]表示按照value的内容来排序

# sort是对原始数据的排序，即执行过sort后原始数据也发生改变；
# 而sorted相当于复制了一个副本，支队副本进行排序，不影响原始数据

# dictC.items()输出的是元组

# ----------------------------------------------拷贝
import copy
dictA = {'name': '深深', 'pos': '歌手', 'school': '乌克兰国立音乐学院', 'age': 28}
dicta1 = copy.copy(dictA)  # 浅拷贝
dicta2 = copy.deepcopy(dictA)  # 深拷贝
print(id(dictA))
print(id(dicta1))
print(id(dicta2))

dicta1['name']='peter'
dicta2['name']='刘德华'
dictA['age'] = 25
print(dicta1)
print(dicta2)
print(dictA)

# 在浅拷贝时，拷贝出来的新对象的地址和原对象是不一样的，
# 但是新对象里面的可变元素（如列表）的地址和原对象里的可变元素的地址是相同的，
# 也就是说浅拷贝它拷贝的是浅层次的数据结构（不可变元素），
# 对象里的可变元素作为深层次的数据结构并没有被拷贝到新地址里面去，而是和原对象里的可变元素指向同一个地址，
# 所以在新对象或原对象里对这个可变元素做修改时，两个对象是同时改变的，但是深拷贝不会这样，这个是浅拷贝相对于深拷贝最根本的区别。

# 深拷贝就是完全跟以前就没有任何关系了，原来的对象怎么改都不会影响当前对象
# 浅拷贝，原对象的list元素改变的话会改变当前对象，如果当前对象中list元素改变了，也同样会影响原对象。
# 浅拷贝就是藕断丝连; 深拷贝就是离婚了


"""
 公用方法 ********************************************************
"""
# ----------------------------------------------合并操作 +
# 字符串
strA = '啊啊啊啊啊'
strB = '啦啦啦啦啦'
print(strA+strB)
# 列表
listA = list(range(10))
listB = list(range(10, 21))
print(listA+listB)
# 元组
tupleA = ('abcd', 89, 9.12, 'p', [11, 22, 33])
tupleB = ('efgh', 22, 1.12, 'f', [55, 66, 77])
print(tupleA+tupleB)

# ----------------------------------------------* 复制
print(strB*3)
print(listB*3)
print(tupleA*3)

# ----------------------------------------------判断元素是否存在
strA = '啊啊啊啊啊'
listA = list(range(10))
tupleA = ('abcd', 89, 9.12, 'p', [11, 22, 33])

print('啊' in strA)
print('我' in strA)

print(0 in listA)
print(22 in listA)

print('abcd' in tupleA)

dictA = {'name': '深深', 'pos': '歌手', 'school': '乌克兰国立音乐学院', 'age': 28}
print('name' in dictA)
print('d' in dictA)





